type rational = { n: int; d: int };

const C1 = [1, 2, 3];
const C2 = 1^3;
-- const C3[i] : int^3 = i;
-- const array_size = 4;

node X(s: int; const array_size: int) returns (A8: int^2);
const array_default = 0;
var 
  A1, A2, A7: int^array_size;
  A3, A4: int^array_size^array_size;
  A5: [int, bool]^array_size;
  A6: rational^array_size;
  A9, A10: int^3;
  i: real;
  r: real;
  -- j: bool;
  x:  int;

let
  assert(array_size > 0);
  -- x= 0 + 0 + 1 - 1 + (s*0) + (array_size*0);
  -- These identifiers are hidden in the array definitions
  -- j = true;
  
  -- A sliding window over input stream s
  A2[k] = if k = 0 then s else (k -> pre A1[k-1]);
  
  -- A pointwise definition of an array
  -- A1[i] = array_default;

  --%PROPERTY A2[0] = s;
  --%PROPERTY A1[3] = s;
  --%PROPERTY A3[1][0] =s; 
  --%PROPERTY x = 0;
  --%PROPERTY i = 0.0;
  --%PROPERTY A5[0] = { 0 ,  true} ;
  --%PROPERTY {0*s, true}.%0 = 0 ;
  --%PROPERTY A6[3].n = 3 ;
  --%PROPERTY A4[1][3] = 4 ;
  --

  -- -- A multi-dimensional array
  A3[i][j] = s;
  
  -- -- A multi-dimensional array, the second i masks the first 
  A4[i][i] = i;
  
  -- -- Structural assignment involving recursive array definition
  (x, A1[i]) = (0, s); -- TODO

  -- -- Array of tuples 
  A5[i] = {i, i mod 2 = 0 };

  -- -- Array of records
  A6[i] = rational { n=i; d=i+1 };

  i =((r * 0.0) / 2.0);
  
  -- -- Temporal operator applied to running variable: legal?
  -- A7[i] = 0 -> pre i;

  -- -- Return an array from a node call
  -- A8[i] = 0;

  -- A9[i] = C1[i] -> pre A9[i] + 1;

  -- A10[i] = C2[i] -> pre A10[i] + 1;

tel
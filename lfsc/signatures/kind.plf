;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                  ;;
;; Signature for k-induction proofs ;;
;;                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Depends on sat.plf, smt.plf, and th_base.plf

;; transition relation
(define rel term)

;; initial term and properties
(define set term)

;; derivability judgment for invariance proofs (P invariant in system (I, S))
(declare invariant (! I set (! T rel (! P set type))))



;;---------------------------

;; derivation judgment for weak observational equivalence between two systems
(declare weak_obs_eq
         (! I1 set (! T1 rel (! P1 set
         (! I2 set (! T2 rel (! P2 set type)))))))


;; rule for proving observational equivalence between two transitions systems
;; with respect to their properties

(declare obs_eq
  (! I1 set (! T1 rel (! P1 set
  (! I2 set (! T2 rel (! P2 set

  ;; indices of lambda abstractions for I, T, and P
  (! a mpz (! b mpz (! c mpz (! d mpz

  ;; Given term to fix inputs as being the same in the two systems
  (! same_inputs set                         

  ;; proof that P1 <=> P2 is invariant in the observer
  (! ue
     (invariant
       ((lambda a Int) (
         (let i (bvar a Int)
         (and (apply same_inputs i) (and (and (apply I1 i) (and (apply I2 i) true)) true)))))
       ((lambda b Int) ((lambda c Int) (
         (let i (bvar b Int)
         (let j (bvar c Int)
         (and (apply same_inputs j) (and (and (apply (apply T1 i) j) (and (apply (apply T2 i) j) true)) true)))))))
       ((lambda d Int) (
         (let k (bvar d Int)
         (= (apply P1 k) (apply P2 k))))))
  ;;------------------------------
  (weak_obs_eq I1 T1 P1 I2 T2 P2)

)))))))))))))


;; derivation judgment for safety (system (I,T) is safe wrt P)
(declare safe (! I set (! T rel (! P set type))))


;; proof rule for proving safety:
;;  - invariance of property of original system
;;  - weak observationnal equivalence with a system generated by a different
;;    frontend

(declare inv+obs
 (! I set
 (! T rel
 (! P set

 (! I' set
 (! T' rel
 (! P' set
    
 ;; proof that P is invariant in (I,T)
 (! i
    (invariant I T P)

 ;; proof that it is weak-obs-equivalent to another system   
 (! weo
    (weak_obs_eq I T P I' T' P')

 ;;----------------------------------
 (safe I T P)

)))))))))



;; Unrolling transition relation k times starting from the initial state
(program unroll_from ((T rel) (I set) (k term)) term
 (mp_ifneg (sc_arith_get_mpz k)
   (fail term)
   (mp_ifzero (sc_arith_get_mpz k)
     (apply I (int 0))
     (let j (int (mp_add (sc_arith_get_mpz k) (~ 1)))
       (and (unroll_from T I j) (and (apply (apply T j) k) true))))))



;; base for k steps
(program base_k ((I set) (T rel) (P set) (k term)) term
 (mp_ifneg (sc_arith_get_mpz k)
   (fail term)
   (mp_ifzero (sc_arith_get_mpz k)
     (and (unroll_from T I (int 0)) (and (not (apply P (int 0))) true))
     (let j (int (mp_add (sc_arith_get_mpz k) (~ 1)))
       (or (base_k I T P j) (or (and (unroll_from T I k) (and (not (apply P k)) true)) false))))))


;; base for k-1 steps
(program base ((I set) (T rel) (P set) (k term)) term
 (base_k I T P (int (mp_add (sc_arith_get_mpz k) (~ 1)))))


;; unroll step case under assumption
(program unroll_with ((T rel) (P set) (k term)) term
 (mp_ifneg (sc_arith_get_mpz k)
   (fail term)
   (mp_ifzero (sc_arith_get_mpz k)
     (apply P (int 0))
     (let j (int (mp_add (sc_arith_get_mpz k) (~ 1)))
       (mp_ifzero (sc_arith_get_mpz j)
          (and (apply P (int 0)) (and (apply (apply T (int 0)) (int 1)) true))
          (and (unroll_with T P j) (and (and (apply P j) (and (apply (apply T j) k) true)) true)))))))


;; program to construct step term
(program step ((T rel) (P set) (k term)) term
  (and (unroll_with T P k) (and (not (apply P k)) true)))


;; Rule for weakening of invariants

(declare invariant-implies2
  (! I set
  (! T rel
  (! P1 set
  (! P2 set

  (! u
     (! k term
     (! v1 (holds (apply P1 k))
     (! v2 (holds (not (apply P2 k)))
        (holds false))))

  (! i1
     (invariant I T P1)
  ;--------------------------------
  (invariant I T P2)

  )))))))



;; Other version

(declare invariant-implies
  (! I set
  (! T rel
  (! P1 set
  (! P2 set

  ;; proof that P1 => P2
  (! u
     (! v (holds (not (=> (apply P1 (int 0)) (apply P2 (int 0)))))
        (holds false))

  ;; proof that P1 is invariant
  (! i1
     (invariant I T P1)

  ;--------------------------------
  (invariant I T P2)

  )))))))


;; Rule for k-induction principle

(declare kinduction
  (! k term     ; bound k
  (! I set      ; initial states
  (! T rel      ; transition relation
  (! P set      ; k-inductice invariant

  (! B term  ; term for base case (see side-condition r1)
  (! r1 (^ (base I T P k) B)

  (! S term  ; term for step case (see side-condition r2)
  (! r2 (^ (step T P k) S)
         
  (! ub (! vb (holds B) (holds false)) ; proof of base

  (! us (! vs (holds S) (holds false)) ; proof of step


  ;------------------------------------
  (invariant I T P)

)))))))))))


;; TODO
;; Compositional

(declare sys-approx (! I1 set (! T1 rel (! I2 set (! T2 rel type)))))

(declare impl-approx
   (! I1 set
   (! T1 rel
   (! I2 set
   (! T2 rel
   (! ui (! k term (holds (=> (apply I1 k) (apply I2 k))))
   (! ui (! i term (! j term (holds (=> (apply (apply T1 i) j) (apply (apply T2 i) j)))))
            (sys-approx I1 T1 I2 T2))))))))

(declare sys-approx-inv
  (! I1 set
  (! T1 rel
  (! I2 set
  (! T2 rel
  (! P set
  (! ua (sys-approx I1 T1 I2 T2)
  (! up (invariant I2 T2 P)
    (invariant I1 T1 P)))))))))
  
(declare contract type)

(declare contract_ag (! Assume set (! Guarantee set (contract))))

(declare respect_contract (! I set (! T rel (! C contract type))))

(declare assume-guarantee
  (! I set
  (! T rel
  (! A set
  (! G set
  (! ag (! ia (invariant I T A) (invariant I T G))
  (respect_contract I T (contract_ag A G))))))))


(declare prop_to_contract
  (! I set
  (! T rel
  (! P set
  ;; index of lambda abstraction
  (! a mpz
  (! up (invariant I T P)
    (respect_contract I T (contract_ag ((lambda a Int) true) P))))))))

(declare contract_to_prop
  (! I set
  (! T rel
  (! A set
  (! G set
  ;; indices of lambda abstractions
  (! a mpz (! b mpz (! c mpz
  (! up (invariant
         ((lambda a Int) (
           (let i (bvar a Int)
             (and (apply I i) (apply A i)))))
         ((lambda b Int) ((lambda c Int) (
           (let i (bvar b Int)
           (let j (bvar c Int)
             (and (apply (apply T i) j) (apply A j)))))))
         G)
    (respect_contract I T (contract_ag A G)))))))))))


(declare abstract_respect_contract
  (! I set
  (! T rel
  (! A set
  (! G set
  ;; index of lambda abstraction
  (! a mpz
  (! ui (invariant A ((lambda a Int) A) G)
    (respect_contract I T (contract_ag A G)))))))))



;;-------------------------------------------------------------------------
;; Some tests

;; (define T (: rel (\ x (\ y (and (= _ (ind x) (ind 1)) (= _ (ind y) (ind 2)))))))
;; (define I (: set (\ x (= _ (ind x) (ind 0)))))

;; (declare T rel)
;; (declare I set)
;; (declare P set)


;; (run (unroll_from T I 4)))
;; ;; result:
;; ;; (and (and (and (and (I 0) (T 0 1)) (T 1 2)) (T 2 3)) (T 3 4))
;; (run (unroll_from T I (~ 1))))
;; ;; result:
;; ;; fail

;; (run (base I T P 2))
;; (run (base I T P 4))
;; (run (base I T P (~ 1)))
;; (run (base I T P 0))
;; (run (base I T P 1))

;; (run (unroll_with T P 4))
;; (run (unroll_with T P 1))
;; (run (unroll_with T P 0))
;; (run (unroll_with T P (~ 1)))

;; (run (step T P 2))
;; (run (step T P 4))

;; ;;-------------------------------------------------------------------------


;; (check

;;  (% xI set
;;  (% xT rel
;;  (% xP set

;;  (% B2 (th_holds (or (and (xI 0) (not (xP 0))) (and (and (xI 0) (xT 0 1)) (not (xP 1)))))
;;  (% S2 (th_holds (and (and (and (xP 0) (xT 0 1)) (and (xP 1) (xT 1 2))) (not (xP 2))))
    
;;  (: (invariant xI xT xP)

;;  (kinduction 2 _ _ _
;;    ;; _ _
;;    ;; B and S can be inferred from the other types (and the side conditions)
;;    (or (and (xI 0) (not (xP 0))) (and (and (xI 0) (xT 0 1)) (not (xP 1))))
             
;;    (and (and (and (xP 0) (xT 0 1)) (and (xP 1) (xT 1 2))) (not (xP 2)))


;;    (\ pb (clausify_false (trust))) ;; hole for proof of base at 2
     
;;    (\ ps (clausify_false (trust))) ;; hole for proof of step at 2

;;  ))))))))

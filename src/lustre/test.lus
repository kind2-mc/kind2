/* This is a comment 
  over several lines */ 

(* OCaml-style comments are 
  also valid -- and that officially *)

-- Free constants, must have a type
const a1, a2, a3: a;

-- Defined constants without type
const b1 = 1;
      pi = 3.14;

-- Defined constant with optional type 
const c1 : bool = true;
      c2 = 5;
      c3, c4 : real;

-- Predefined type bool
type a = bool;

-- Declaration of multiple aliases for predefined type int
type b, c = int;

-- Predefined type integer range (our extension)
type r1 = subrange [1, 2] of int;
type r2 = subrange [-2, 2] of int;
type r3 = subrange [b, c] of int;

-- Predefined type real
type d = real;

-- User-defined type
type e = a;

-- Tuple type
type f = [int, real, bool];

-- Nested tuple type
type g = [d, [int, bool]];

-- Record type (V6)
type h = struct { one : int; two : bool };

-- Record types can be nested, struct is optional
type i = { one: struct { a : int; b: bool };  two : bool; };

-- Enum type (V6) 
type e = enum {blue, green, red };

-- Array types
type f = int^5;
type g = int^5^5; -- ^ is left-associative
type h = int^5*h;

-- A node declaration
node x 
  (a, b: [int, [bool, bool]]; 
   const c: z; d, e: int when a; 
   (f, g: int; h: real;) when b) 
returns 
  (x: y when z; 
   (a, b: [int, [bool, real]]; c: struct {one: real; two: int }) when x;
   d: int);
-- Variable declarations are optional
let 
-- Node equations are optional
tel;

node y (const a: bool) returns (b: int);
-- Local constant declarations
const c : int; d = 1;
var t : {a: int; b: real};
let

  e = 1;
  (f) = 2;

  -- Main node annotation, anything can follow, semicolon is not
  --necessary,  can be anywhere in the node body 

  --%MAIN 
  --%MAIN; 
  --%MAIN xyz

  -- Assignment to a list
  g, h, i = x(c);

  -- List can be in parentheses
  (j, k, l, m) = (true, false, 1, 2.0);

  -- Structural assignment from array
  [n, o, p] = 1^3;

  -- Structural assignment
  [c, [A[0], A[1]]] = e;

  -- Structural assignment to tuple 
  [q, r] = [true, 5];

  -- Assignment to array slices 
  A[i..j] = 3^(i-j);
  B[i..j, k..l] = 3^(j-i)^(l-k);

  -- Assignment to record field
  t.a = y(5);
  
  -- Record construction
  t = { b = 2.0; a = 1 };
  
  t.b = if a xor d then #(a, b, c) else false; 
  
  -- Assertion
  assert x;

  -- Property, must be terminated with a semicolon
  --%PROPERTY k; 

  -- Annotations can be commented 
  -- --%PROPERTY j;

-- A node can end with tel; tel. or tel
tel.


-- Node contracts right after its signature 
node g () returns ();
--@requires x;
--@ensures y;
const n = 5;
var t : int;
let t = n; tel;


-- A node with a type parameter 
node changed<<type t>> (b: t) returns (ok: bool); 
let ok = false ->  not (pre b = b); tel; 

-- A node using a parametric node
node x (x: bool; y: int;) returns (z: bool);
let z = changed<<bool>>(x) or changed<<int>>(y); tel

-- Nodes defined as instances of a parametric node 
node changed_int = changed<<int>>;
node changed_bool = changed<<bool>>;



-- An uninterpreted function, parameters cannot be clocked or have
-- constant parameters
function y (a: bool; c: int) returns (b: int);
function y (a: bool; c: int; ) returns (b: int);


------------------------------------------------------------------------
-- Examples from the reference manual

-- Section 1

node count (x, y: int) returns (s: int);
let
  s = 2 * (x+y);
tel

node EDGE (X: bool) returns (Y: bool);
let
  Y = false -> X and not pre(X);
tel

node FALLING_EDGE (X: bool) returns (Y: bool);
let
  Y = EDGE(not X);
tel

node SWITCH1 (set, reset, initial: bool) returns (level: bool);
let
  level = initial -> if set then true else if reset then false else pre(level);
  assert not (set and reset);
tel


node SWITCH (set, reset, initial: bool) returns (level: bool);
let
  level = initial -> if set and not pre(level) then true else if reset then false else pre(level);
tel

node x1 () returns ();
var
  N1, PN, N2, N3, N4: int;
let
  N1 = 0 -> if X then pre N + 1 else pre N;
  PN = 0 -> pre N;
  N = if X then PN + 1 else PN;
  N = if X then (0 -> pre N) + 1 else (0 -> pre N);
  N = (0 -> pre N) + if X then 0 else 1;
tel

node COUNTER (init, incr: int; X, reset: bool) returns (N: int);
var PN: int;
let
  PN = init -> pre N;
  N = if reset then init else if X then PN + incr else PN;
tel

node x2 () returns ();
var odds: int;
let
  odds = COUNTER(0, 2, true, false);
  mod10 = COUNTER(0, 1, true, reset);
  reset = true -> pre(mod10) = 9;
tel

node integrator (F, STEP, init: real) returns (Y: real);
let
  Y = init -> pre(Y) + ((F + pre(F))*STEP)/2.0;
tel

-- This has a dependency loop
node sincos(omega: real) returns (sin, cos: real);
let
  sin = omega * integrator(cos, 0.1, 0.0);
  cos = omega * integrator(-sin, 0.1, 1.0);
tel


node sincos (omega: real) returns(sin, cos: real);
let
  sin = omega * integrator(cos, 0.1, 0.0);
  cos = omega * integrator(0.0 -> -pre(sin), 0.1, 1.0);
tel

node x3 () returns ();
let 
  (s, c) = sincos(omega);
  (min, max) = if a > b then (a, b) else (b, a);
tel

node STABLE (set: bool; delay: int) returns (level: bool);
var count: int;
let 
  level = (count > 0);
  count = if set then delay 
          else if false -> pre(level) then pre(count) -1
               else 0;
tel

node TIME_STABLE (set, second: bool; delay: int) returns (level: bool);
var count: int;
let
  level = (count > 0);
  count = if set then delay
          else if second then 
                 if false -> pre(level) then pre(count) - 1 
                 else 0
               else (0 -> pre(count));
tel

node TIME_STABLE (set, second: bool; delay: int) returns (level: bool);
var ck: bool;
let
  level = current(STABLE((set, delay) when ck));
  ck = true -> set or second;
tel

-- Section 2

type TIME, DAY;
type DISPLAY = [TIME, DAY];
const initial_time: TIME;
const Mo, Tu, We, Th, Fr, Sa, Su: DAY;
function Increment_Time (time: TIME) returns (new_time: TIME; change_day: bool);
function ToMorrow (today: DAY) returns (tomorrow: DAY);
node Timer (second: bool) returns (display: DISPLAY);
var time: TIME; day: DAY; change_day: bool;
let
  display = [time, day];
  (time, change_day) = 
    (initial_time, false) -> if second then Increment_Time(pre time)
                             else pre(time, change_day);
  day = Mo -> if change_day then ToMorrow(pre day) else pre day;
tel

const 
  size = 32;
  unknown: int;
type T;
node N (const n: int) returns (x: int);
var V: T^(2*n);
let
tel;

node x21 () returns ();
var X1, X2: int;
let
  X = N(size+1); -- is correct
  X = N(unknown); -- is rejected
tel

type T = int^3^5;
type complex = [real, real];

node x22 () returns ();
var x, y: complex;
let tel;

const 
  PI = 3.1416;
  RightAngle = PI/2.0;

const size = 64;
type vector = int^size;

node x23 () returns ();
var 
  state: bool;
  coordinates: [real, real] when state;
let tel;


-- Section 5

function increment (time: time) returns (newtime: time);
function decompose (time: time) returns (hours, minute, second: int);

node x51 (updated_time, actual_time: time) returns (H, M, S: int);
let
  (H, M, S) = if update 
              then decompose(updated_time) 
              else decompose(increment(actual_time));
tel

node N (x, y: bool; const low, high: int) returns ();
let tel;

node M (x, y: bool; a: int when x; (b: int; r: real) when y) returns ();
let tel;

node N2 (c: bool; a: int when c) returns (d: bool when c; b: int when d);
let tel;

node x52 (E1: bool; E2: int when E1) returns (F1: bool; F2: int);
let 
  (F1, F2) = N(E1, E2);
tel;

-- Section 6

node N (U, V, W: int) returns (X: int; Y: real); let tel;

node x61 (C: bool; E, E1: int; F, F1: real) returns (X: int; Y: real);
let 
  (X, Y) = if C then (E, F) else (E1, F1);
  (X, Y) = (E, F) -> pre (X, Y);
  (X, Y) = (E, F) when C;
  (X, Y) = N(U, V, W);
tel


node N (a, b: int) returns (c, d: int);
let (c, d) = (a, b); tel

node x62 (E, F, G, H: int) returns (A, B, C, D: int);
let 
  (A, B, C, D) = (N(E, F), N(G, H));
tel;

node x63 (e: [bool, [int, int]]) returns (c: bool; a, b: int; A: [int, int]);
let
  [c, [a, b]] = e;
  [c, A] = e;
  c = e[0]; a = e[1][0]; b = e[1][1];
  c = e[0]; A = e[1];
  [c, [A[0], A[1]]] = e;
tel;


-- Section 7

node N (x1, x2, x3: int) returns (y1, y2, y3: int);
let 
  (x1, x2, x3) = (y1, y2, y3);
tel

node x71 (C: bool) returns ();
let 
  (y1, y2, y3) = condact(C, N(x1, x2, x3), v1, v2, v3);
  (y1, y2, y3) = if C then current(N((x1, x2, x3) when C)) 
                 else (v1, v2, v3) -> pre(y1, y2, z3);
tel

node x72 (e1 : int; e2: real; e3: bool) returns (e: [int, real, bool]; f: real);
let
  e = [e1, e2, e3];
  f = e[1];
tel

node x73 (a, b: int) returns (e1, e2, e3, e4: int);
let
  e1 = a + 2 * b;
  e2 = a + b - c;
  e3 = not a = b;
  e4 = if c then a else e -> f;
tel

node x74 (e1, e2, e3: int; f2: bool) returns (e: int^3; f: [int, bool, int]);
let
  e = [e1, e2, e3];
tel

node x75 (a: int^5) returns (a1: int; a23: int^2);
const A = [1, 2, 3, 4, 5, 6];
var
  b1 : int;
  b2, b3: int^3;
  b4 : int^1;
  b5: int; 
let
  a1 = a[0];
  a23 = a[2..3];
  b1 = A[1];
  b2 = A[2..4];
  b3 = A[4..2];
  b4 = A[2..2];
  b5 = A[2..4][0];
tel

node x76 (A: T^10^5) returns (B1: T^10^2; B2: T^2^4; B3: int^5 );
let
  B1 = A[1..4][1..2];
  B2 = A[1..4, 1..2];
  B3 = [1, 2, 3] | [4, 3];
tel

node EQ (const n: int; A, B: int^n) returns (equal: bool);
var C, E: bool^n;
let
  equal = C[n-1];
  C = [E[0]]|C[0..n-2] and E[1..n-1];
  E = (A = B);
tel

node DELAY (const n, default: int;X: int) returns (delayed: int);
var window: int^n;
let
  delayed = window[n-1];
  window = [X]|(default^(n-1) -> pre(window[0..n-2]));
tel

-- Examples from the V6 draft manual
type color1 = enum { blue, white, black };
type color2 = enum { green, orange, yellow };

node enum0 (x: color1) returns (y: color2);
let
  y = if x = blue then green else if x = white then orange else yellow;
tel

type complex = { re: real; im: real };
const j = { re = -sqrt(3)/2; im = sqrt(3)/2 };

node get_im(c: complex) returns (x: real);
let
  x = c.im;
tel

type matrix_3_3 = int^3^3;
const m1 = 0^3^3;
const m2 = [1, 2, 3]^3;
const sm2 = m2[2];

